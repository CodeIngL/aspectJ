### AspectJ实施要点 ###

### 编译器注释 ###

AspectJ的初始实现都是基于编译器的实现。 AspectJ语义的某些元素很难在不修改虚拟机的情况下实现，这是基于编译器的实现所不能做到的。处理这个问题的一种方法是只指定最容易实现的行为。我们选择了一种稍微不同的方法，即指定理想的语言语义，以及允许实现与该语义偏离的明确定义的方式。这使得今天开发符合AspectJ的实现成为可能，同时还明确了明天实施应该做什么以及可能更好的实现。

根据AspectJ语言语义，该声明

	  before（）：get（int Point.x）{System.out.println（“got x”）; }


应该告诉所有类型int（或子类型）Point实例的int类型和名称x的访问。它应该这样做，无论执行访问的所有源代码在包含此建议的方面编译时是否可用，是否稍后进行更改等等。

但是允许AspectJ实现以一种明确定义的方式偏离它 - 它们被允许建议只在代码中访问实现控件。每个实现在一定的范围内是自由的，以提供它自己定义的控制代码的含义。

在当前的AspectJ编译器ajc中，对代码的控制意味着在编译期间为任何方面以及它们应该影响的所有代码提供字节码。这意味着如果某些类的客户端包含带有新的Point（）。x（它在运行时会产生一个字段get连接点）的代码，那么当前的AspectJ编译器将无法通知该访问，除非Client.java或Client.class为编译也是如此。这也意味着不能建议与本地方法中的代码（包括它们的执行连接点）相关的连接点。

不同的连接点有不同的要求。只有当ajc控制调用者的字节码时，方法和构造函数调用连接点才能被建议。只有当ajc控制“调用者”的字节码时，字段引用或赋值连接点才能被建议，代码实际上是引用或赋值。只有当ajc控制被初始化的类型的字节码时才能建议初始化连接点，并且只有在ajc控制正在讨论的方法或构造函数体的字节码时才能建议执行连接点。异常处理程序的末尾在字节码中是未定的，因此ajc不会在处理程序连接点的后面或周围实现。同样，ajc无法实现关于初始化或预初始化连接点的建议。在ajc无法实现建议的情况下，它会发出编译时错误，并将其视为编译器限制。

根据代码的控制，定义的方面也受到限制。特别是，在当前正在执行的对象的字节码不可用的连接点处，该连接点的一个方面定义的关联将不会关联。因此定义的方面perthis（Object）不会为每个对象创建方面实例，除非Objectis是编译的一部分。类似的限制适用于pertarget方面。


诸如声明父母之类的类型间声明也有基于代码控制的限制。如果类型间声明的目标字节码不可用，则不在该目标上进行类型间声明。因此，声明父母：字符串实现MyInterface不会为java.lang.String工作，除非java.lang.String是编译的一部分。

在接口上声明成员时，实现必须控制该接口的接口和顶级实现者（实现接口的类，但没有实现接口的超类）。你可以单独编织它们，但要注意，如果你运行受影响的顶层类而没有由相同的ajc实现产生的接口，你将得到运行时异常。任何接口上的抽象方法的intertype声明都必须指定为public，如果不指定public，则会得到编译时错误消息，指出这是编译器限制。在接口上声明的非抽象方法可以使用除protected之外的任何访问修饰符。请注意，这与普通Java规则不同，其中在接口中声明的所有成员都是隐式公开的。最后，请注意，无法在接口上定义静态字段或方法。

在目标类型上声明方法时，只有public方法可以在字节码中识别，所以方法必须声明为public，以便在任何子类型中重写，或者在稍后使用目标类型作为库进行编译时从代码中调用。

其他的AspectJ实现，实际上，ajc的未来版本，可以更自由地或限制性地定义代码实现控制，只要它们符合Java语言。例如，调用pointcut不会选择对java.lang.reflect.Method.invoke（Object，Object []）中实现的方法的反射调用。一些人认为调用“发生”，调用pointcut应该挑选出来，但AspectJ语言不应该预测实现控制之外的代码会发生什么，即使它是Java标准库中定义明确的API 。

要记住的重要一点是，AspectJ的核心概念（如连接点）不会改变，无论使用哪种实现。在您的开发过程中，您必须了解您使用的ajc编译器的局限性，但这些限制不应推动您的方面的设计。


### 字节码注释 ###

### .class表达式和String + ###

Java语言形式Foo.class在字节码中实现，调用Class.forName的方式由捕获ClassNotFoundException的异常处理程序保护。

Java语言+运算符应用于String参数时，通过调用StringBuffer.append以字节码形式实现。

在这两种情况下，当前的AspectJ编译器都会对这些语言特性的字节码实现进行操作; 简而言之，它运行在真正发生的事情上，而不是源代码中编写的内容。 这意味着可能有来自程序的Class.forName或StringBuffer.append的联接点，乍看之下似乎并不包含这样的调用：



	  class Test {
	      void main(String[] args) {
	          System.out.println(Test.class);        // calls Class.forName
	          System.out.println(args[0] + args[1]); // calls StringBuffer.append
	      }
	  }

简而言之，当前AspectJ编译器的连接点模型将它们视为有效的连接点。

### 处理程序连接点 ###

在Java字节码中不能可靠地找到异常处理程序的结尾。 当前的AspectJ编译器并没有完全删除处理器连接点，而是限制了处理器连接点可以做什么：

之后和周围的建议不能应用于处理程序连接点。
无法检测处理程序连接点的控制流。
其中第一个比较简单。 如果任何一条after通知（返回，抛出或“finally”）通常应用于处理程序连接点，它将不会由当前的AspectJ编译器输出代码。 如果检测到这种情况，则会生成编译器警告。 在允许建议之前。

第二个是处理程序连接点的控制流没有被选出。 例如，下面的切入点

	cflow(call(void foo()) || handler(java.io.IOException))

将捕获调用的控制流中的所有连接点以void foo（），但它不会捕获IOException处理程序的控制流中的那些连接点。 它相当于cflow（call（void foo（）））。 一般来说，cflow（handler（Type））不会挑选出任何连接点，对此的一个例外是在处理程序的任何before建议执行期间发生的连接点。

这并不限制程序在处理其他控制流程中的处理程序建议之前。 例如，这个建议非常好：

	  before(): handler(java.io.IOException) && cflow(void parse()) {
	      System.out.println("about to handle an exception while parsing");
	  }


AspectJ的源代码实现（如AspectJ 1.0.6）能够检测处理程序连接点的端点，因此可能会有更少的这种限制。

### 初始化器和类型间构造器 ###

Java初始化程序的代码，例如赋值给d中的字段

	  class C {
	      double d = Math.sqrt(2);
	  }


在AspectJ获取字节码的时候被认为是构造函数的一部分。 也就是说，d的平方根分配在C的默认构造函数内部

因此，类型间构造函数不一定会运行目标类型的初始化代码。 特别是，如果类型间构造函数调用超级构造函数（与此构造函数相对），则在调用类型间构造函数时，不会运行目标类型的初始化代码。

	  aspect A {
	      C.new(Object o) {} // implicitly calls super()
	
	      public static void main(String[] args) {
	         System.out.println((new C()    ).d);    // prints 1.414...
	         System.out.println((new C(null)).d);    // prints 0.0
	  }

执行所有必需的初始化或者在必要时委托给此构造函数是一个类型间构造函数的工作。


### 注释式注释 ###

由于二进制方面采用相同的形式并以相同的方式编织，因此在注释风格中编写方面受到相同的字节码限制。 但是，实现差异（例如，实现周围建议的机制）在运行时可能很明显。 有关更多信息，请参阅关于注释样式的文档。


### 实施要求摘要 ###


这总结了我们实施AspectJ的要求。有关更多详细信息，请参阅本指南的相关部分。

- 调用代码必须在ajc的控制下，用于以下连接点：

	- 调用连接点
	- 获得连接点
	- 设置连接点

- 声明/目标代码必须在ajc的控制下，用于以下连接点和类型间声明：

	- 执行连接点
	- adviceexecution连接点
	- 处理程序连接点
	- 初始化连接点
	- 预初始连接点
	- 静态初始化连接点
	- perthis方面
	- pertarget方面
	- 宣布父母
	- 声明方法或字段（请参阅下面的接口警告）

- 实施警告

	- 初始化和预初始化连接点不支持周围的建议

	- 处理程序连接点不支持...

		- 经过建议
		- 围绕建议
		- cflow的（处理器（..））
	- 在一个方面的接口中声明成员只影响实现控件的最顶层实现类。

	- cflow和cflowbelow切入点在单个线程内工作。

	- 运行时ClassCastException可能是由于提供了一个实参类型的超类作为参数以在around通知中继续（..）。