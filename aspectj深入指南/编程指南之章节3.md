### AspectJ例子 ###

本章完全由AspectJ使用的示例组成。

这些例子可以分为四类：

技术举例说明如何使用该语言的一个或多个功能。
开发在项目开发阶段使用AspectJ的例子。
生产使用AspectJ在应用程序中提供功能的示例。
可重用的方面和切入点的重用示例。


### 获取，编译和运行示例 ###


示例源代码是可以从AspectJ项目页面（http://eclipse.org/aspectj）下载的AspectJ发行版的一部分。

编译大多数例子很简单。 转到InstallDir / examples目录，然后在其中一个示例子目录中查找.lst文件。 使用-arglist选项来编译示例。 例如，要用电子帐单编辑电信示例，请键入

	ajc -argfile telecom/billing.lst

要运行这些示例，您的类路径必须包含AspectJ运行时Java归档文件（aspectjrt.jar）。 您可以设置CLASSPATH环境变量，也可以对Java解释器使用-classpath命令行选项：


	(In Unix use a : in the CLASSPATH)
	java -classpath ".:InstallDir/lib/aspectjrt.jar" telecom.billingSimulation


	(In Windows use a ; in the CLASSPATH)
	java -classpath ".;InstallDir/lib/aspectjrt.jar" telecom.billingSimulation


### 基本技术 ###

本节介绍了使用AspectJ的两种基本技巧，分别从捕获横切关注点的两个基本方法中获取：动态连接点和建议以及静态引入。 建议会改变应用程序的行为。 简介改变了应用程序的行为和结构。

第一个例子，名为“Join Points and thisJoinPoint”的部分是关于收集和使用关于已经触发一些建议的连接点的信息。 第二个例子，称为“角色和视图”部分，涉及现有类层次结构的横切视图。

### 连接点和thisJoinPoint ###

（这个例子的代码在InstallDir / examples / tjp中。）


一个连接点是程序执行过程中的一个点，以及该点出现时执行上下文的视图。 加入点由切入点选出。 当一个程序到达一个连接点时，关于该连接点的建议可以在连接点本身之外运行（或代替）。

当使用按名称挑选单一类型连接点的切入点时，通常建议将知道它与哪种连接点相关联。 切入点甚至可以发布关于连接点的上下文。 在这里，例如，由于切入点选出的唯一连接点是某个方法的调用，我们可以直接获取目标值和方法调用的参数值之一。


	before(Point p, int x): target(p)
	                     && args(x)
	                     && call(void setX(int)) {
	    if (!p.assertX(x)) {
	        System.out.println("Illegal value for x"); return;
	    }
	}

但有时连接点的形状不太清楚。 例如，假设正在调试一个复杂的应用程序，并且我们希望在某个类的任何方法被执行时进行跟踪。 切入点

	pointcut execsInProblemClass(): within(ProblemClass)
                             && execution(* *(..));

将挑出ProblemClass中定义的每个方法的每个执行连接点。 由于建议在切入点挑出的每个连接点执行，因此我们可以合理地询问到达哪个连接点。


有关已匹配连接点的信息可用于通过org.aspectj.lang.JoinPoint类型的特殊变量thisJoinPoint进行建议。 通过这个对象我们可以访问诸如

- 匹配的连接点的种类
- 与连接点关联的代码的源位置
- 当前连接点的正常，短期和长期字符串表示
- 连接点的实际参数值
- 与连接点关联的成员签名
- 当前正在执行的对象
- 目标对象
- 一个封装关于连接点的静态信息的对象。 这也可以通过特殊变量thisJoinPointStaticPart获得。

Demo类

tjp / Demo.java中的类tjp.Demo使用不同的参数列表和返回类型定义了两个方法foo和bar。 两者都通过适当的参数，通过Demo的go方法调用，该方法在主方法中调用。


	public class Demo {
	    static Demo d;
	
	    public static void main(String[] args){
	        new Demo().go();
	    }
	
	    void go(){
	        d = new Demo();
	        d.foo(1,d);
	        System.out.println(d.bar(new Integer(3)));
	    }
	
	    void foo(int i, Object o){
	        System.out.println("Demo.foo(" + i + ", " + o + ")\n");
	    }
	
	    String bar (Integer j){
	        System.out.println("Demo.bar(" + j + ")\n");
	        return "Demo.bar(" + j  + ")";
	    }
	}

GetInfo方面

这方面使用around建议来拦截Demo中的foo和bar方法的执行，并将从thisJoinPoint获得的信息输出到控制台。

	aspect GetInfo {
	
	   static final void println(String s){ System.out.println(s); }
	
	   pointcut goCut(): cflow(this(Demo) && execution(void go()));
	
	   pointcut demoExecs(): within(Demo) && execution(* *(..));
	
	   Object around(): demoExecs() && !execution(* go()) && goCut() {
	      println("Intercepted message: " +
	          thisJoinPointStaticPart.getSignature().getName());
	      println("in class: " +
	          thisJoinPointStaticPart.getSignature().getDeclaringType().getName());
	      printParameters(thisJoinPoint);
	      println("Running original method: \n" );
	      Object result = proceed();
	      println("  result: " + result );
	      return result;
	   }
	
	   static private void printParameters(JoinPoint jp) {
	      println("Arguments: " );
	      Object[] args = jp.getArgs();
	      String[] names = ((CodeSignature)jp.getSignature()).getParameterNames();
	      Class[] types = ((CodeSignature)jp.getSignature()).getParameterTypes();
	      for (int i = 0; i < args.length; i++) {
	         println("  "  + i + ". " + names[i] +
	             " : " +            types[i].getName() +
	             " = " +            args[i]);
	      }
	   }
	}

定义切入点的范围

切入点goCut被定义为

	cflow(this(Demo)) && execution(void go())

所以只有在Demo.go的控制流中执行的执行才会被拦截。 来自方法go的控制流包括执行go本身，所以around通知的定义包括执行（* go（））以将其从建议的执行集中排除。
打印类和方法名称

方法的名称和该方法的定义类可以作为通过在thisJoinPoint或thisJoinPointStaticPart上调用getSignature（）返回的org.aspectj.lang.Signature对象的一部分来提供。

打印参数

参数细节的静态部分，参数的名称和类型可以通过与连接点关联的org.aspectj.lang.reflect.CodeSignature来访问。 所有执行连接点都有代码签名，因此对代码签名的强制转换不会失败。

参数细节的动态部分，参数的实际值，可直接从执行连接点对象访问。

### 角色和观点 ###

（这个例子的代码在InstallDir / examples / introduction中。）

像建议一样，类型间声明是一个方面的成员。他们宣布那些行为就好像他们被定义在另一个班上的成员一样。与通知不同，类型间声明不仅影响应用程序的行为，还影响应用程序类之间的结构关系。

这是至关重要的：公开地影响应用程序的类结构会使这些修改可用于应用程序的其他组件。

方面可以声明内部类型

	- 领域
	- 方法
	- 建设者
并且还可以声明目标类型

	- 实现新的接口
	- 扩展新的类
	
这个例子提供了三种使用类型间声明来封装类的角色或视图的例子。我们的方面将要处理的类是Point，它是一个具有矩形和极坐标的简单类。我们的类型间声明将使类Point成为可复制，可排列和可比较的类。这些工具由AspectJ提供，无需修改类Point的代码。

Point类

Point类定义几何点，其界面包括极坐标和直角坐标，以及一些简单的操作来重新定位点。点的实现具有极坐标和直角坐标的属性，以及用于指示哪些当前反映点的位置的标志。有些操作会导致极坐标从矩形更新，有些操作会产生相反的效果。该实现中，这是在为了给坐标系之间的转换的最小数目，具有，并非所有存储在一个点对象的属性是必要的以得到规范表示例如可能被用于存储，比较，克隆或财产从点制作散列码。因此，这些方面虽然简单，但并非完全无关紧要。

下面的图表概述了各个方面及其与类Point的交互。

![](http://www.eclipse.org/aspectj/doc/released/progguide/aspects.gif)


CloneablePoint方面

第一个方面负责Point对Cloneable接口的实现。 它声明Point使用declare父表单实现了Cloneable，并且还公开声明了专门的Point的clone（）方法。 在Java中，所有对象都从类Object继承方法克隆，但对象不可复制，除非其类也实现了Cloneable接口。 另外，对于Object.clone所做的简单的逐位复制，类经常会有要求。 在我们的例子中，我们想在实际克隆Point之前更新一个Point的坐标系。 所以我们的方面确保Point用一个新的方法来覆盖Object.clone，这个方法就是我们想要的。

为了方便起见，我们还在这方面定义了测试主要方法。


	public aspect CloneablePoint {
	
	   declare parents: Point implements Cloneable;
	
	   public Object Point.clone() throws CloneNotSupportedException {
	      // we choose to bring all fields up to date before cloning.
	      makeRectangular();
	      makePolar();
	      return super.clone();
	   }
	
	   public static void main(String[] args){
	      Point p1 = new Point();
	      Point p2 = null;
	
	      p1.setPolar(Math.PI, 1.0);
	      try {
	         p2 = (Point)p1.clone();
	      } catch (CloneNotSupportedException e) {}
	      System.out.println("p1 =" + p1 );
	      System.out.println("p2 =" + p2 );
	
	      p1.rotate(Math.PI / -2);
	      System.out.println("p1 =" + p1 );
	      System.out.println("p2 =" + p2 );
	   }
	}

ComparablePoint方面

ComparablePoint负责Point的Comparable接口的实现。

Comparable接口定义了单个方法compareTo，它可以用来定义实现它的类的对象之间的自然顺序关系。

ComparablePoint使用声明父项来声明Point实现Comparable，并且还公开声明适当的compareTo（Object）方法：如果p1更靠近原点，则称p1点小于另一个p2点。

为了方便起见，我们还在这方面定义了测试主要方法。


	public aspect ComparablePoint {
	
	   declare parents: Point implements Comparable;
	
	   public int Point.compareTo(Object o) {
	      return (int) (this.getRho() - ((Point)o).getRho());
	   }
	
	   public static void main(String[] args){
	      Point p1 = new Point();
	      Point p2 = new Point();
	
	      System.out.println("p1 =?= p2 :" + p1.compareTo(p2));
	
	      p1.setRectangular(2,5);
	      p2.setRectangular(2,5);
	      System.out.println("p1 =?= p2 :" + p1.compareTo(p2));
	
	      p2.setRectangular(3,6);
	      System.out.println("p1 =?= p2 :" + p1.compareTo(p2));
	
	      p1.setPolar(Math.PI, 4);
	      p2.setPolar(Math.PI, 4);
	      System.out.println("p1 =?= p2 :" + p1.compareTo(p2));
	
	      p1.rotate(Math.PI / 4.0);
	      System.out.println("p1 =?= p2 :" + p1.compareTo(p2));
	
	      p1.offset(1,1);
	      System.out.println("p1 =?= p2 :" + p1.compareTo(p2));
	   }
	}


HashablePoint方面

我们的第三个方面是负责Point的重写Object的equals和hashCode方法，以使点可哈希。

Object.hashCode方法返回一个整数，适合用作散列表键。并不要求两个不相等的对象（根据equals方法）从hashCode返回不同​​的整数结果，但当整数用作数据结构的关键字时，它可以提高性能。但是，任何两个相等的对象必须从调用hashCode返回相同的整数值。由于Object.equals的默认实现仅在两个对象相同时返回true，因此我们需要重新定义equals和hashCode，以便与Point类型的对象正常工作。例如，我们希望两个Point对象在具有相同的x和y值或相同的rho和theta值时测试相等，而不仅仅当它们引用同一个对象时。我们通过覆盖类Point中的方法equals和hashCode来完成此操作。

所以HashablePoint声明Point的hashCode和equals方法，使用Point的直角坐标生成一个哈希码并测试是否相等。 x和y坐标是使用适当的get方法获得的，它们确保直角坐标在返回其值之前是最新的。

再次，我们提供了一个测试方面的主要方法。


	public aspect HashablePoint {
	
	   public int Point.hashCode() {
	      return (int) (getX() + getY() % Integer.MAX_VALUE);
	   }
	
	   public boolean Point.equals(Object o) {
	      if (o == this) { return true; }
	      if (!(o instanceof Point)) { return false; }
	      Point other = (Point)o;
	      return (getX() == other.getX()) && (getY() == other.getY());
	   }
	
	   public static void main(String[] args) {
	      Hashtable h = new Hashtable();
	      Point p1 = new Point();
	
	      p1.setRectangular(10, 10);
	      Point p2 = new Point();
	
	      p2.setRectangular(10, 10);
	
	      System.out.println("p1 = " + p1);
	      System.out.println("p2 = " + p2);
	      System.out.println("p1.hashCode() = " + p1.hashCode());
	      System.out.println("p2.hashCode() = " + p2.hashCode());
	
	      h.put(p1, "P1");
	      System.out.println("Got: " + h.get(p2));
	   }
	}


### 发展方面 ###
#### 使用方面进行跟踪 ####


（这个例子的代码在InstallDir / examples / tracing中。）

编写一个提供跟踪功能的类很容易：一些函数，用于打开和关闭跟踪的布尔标志，用于输出流的选择，可能是用于格式化输出的一些代码 - 这些都是Trace类所有的元素已知有。如果追踪程序执行的任务需要追踪类，追踪类也可能非常复杂。

但是，开发对追踪的支持只是将追踪插入到程序中的一部分，并且很可能不是最重要的部分。另一部分工作是在适当的时候调用跟踪功能。在大型系统中，跟踪支持的这种互动可能会非常困难。另外，跟踪是降低系统速度的因素之一，所以这些调用通常应该在产品发货之前从系统中取出。由于这些原因，开发人员通常在方法体前后插入/删除跟踪调用来编写专门的脚本程序来重写源代码并不罕见。

AspectJ可以用一些不太专门的方式用于这些追踪问题。跟踪可以被视为横切整个系统的问题，因此可以在一个方面进行封装。另外，它与系统正在做的事情相当独立。因此，跟踪是可能被插入和拔出的那些系统方面之一，在系统的基本功能中没有任何副作用。

示例应用程序

在整个例子中，我们将使用仅包含四个类的简单应用程序。 该应用程序是关于形状。 TwoDShape类是形状层次结构的根：

	public abstract class TwoDShape {
	    protected double x, y;
	    protected TwoDShape(double x, double y) {
	        this.x = x; this.y = y;
	    }
	    public double getX() { return x; }
	    public double getY() { return y; }
	    public double distance(TwoDShape s) {
	        double dx = Math.abs(s.getX() - x);
	        double dy = Math.abs(s.getY() - y);
	        return Math.sqrt(dx*dx + dy*dy);
	    }
	    public abstract double perimeter();
	    public abstract double area();
	    public String toString() {
	        return (" @ (" + String.valueOf(x) + ", " + String.valueOf(y) + ") ");
	    }
	}

TwoDShape有两个子类，Circle和Square：


	public class Circle extends TwoDShape {
	    protected double r;
	    public Circle(double x, double y, double r) {
	        super(x, y); this.r = r;
	    }
	    public Circle(double x, double y) { this(  x,   y, 1.0); }
	    public Circle(double r)           { this(0.0, 0.0,   r); }
	    public Circle()                   { this(0.0, 0.0, 1.0); }
	    public double perimeter() {
	        return 2 * Math.PI * r;
	    }
	    public double area() {
	        return Math.PI * r*r;
	    }
	    public String toString() {
	        return ("Circle radius = " + String.valueOf(r) + super.toString());
	    }
	}


	
	public class Square extends TwoDShape {
	    protected double s;    // side
	    public Square(double x, double y, double s) {
	        super(x, y); this.s = s;
	    }
	    public Square(double x, double y) { this(  x,   y, 1.0); }
	    public Square(double s)           { this(0.0, 0.0,   s); }
	    public Square()                   { this(0.0, 0.0, 1.0); }
	    public double perimeter() {
	        return 4 * s;
	    }
	    public double area() {
	        return s*s;
	    }
	    public String toString() {
	        return ("Square side = " + String.valueOf(s) + super.toString());
	    }
	}

要运行此应用程序，请编译这些类。 你可以使用或不使用ajc，AspectJ编译器。 如果您安装了AspectJ，请转至目录InstallDir / examples并键入：


	ajc -argfile tracing/notrace.lst

要运行该程序，请键入

	java tracing.ExampleMain

（因为这是纯Java代码，所以我们不需要特别的类路径）。 您应该看到以下输出：

	c1.perimeter() = 12.566370614359172
	c1.area() = 12.566370614359172
	s1.perimeter() = 4.0
	s1.area() = 1.0
	c2.distance(c1) = 4.242640687119285
	s1.distance(c1) = 2.23606797749979
	s1.toString(): Square side = 1.0 @ (1.0, 2.0)


**追踪 - 版本1**

在第一次尝试在此应用程序中插入跟踪时，我们将开始编写一个跟踪类，如果我们没有方面的话，这正是我们要写的。 该实现在版本1 / Trace.java中。 其公共接口是：


	public class Trace {
	    public static int TRACELEVEL = 0;
	    public static void initStream(PrintStream s) {...}
	    public static void traceEntry(String str) {...}
	    public static void traceExit(String str) {...}
	}


如果我们没有AspectJ，我们必须在所有想跟踪的方法和构造函数中插入对traceEntry和traceExit的调用，并初始化TRACELEVEL和流。 如果我们想要在我们的例子中追踪所有的方法和构造函数，那么大约需要40次调用，我们希望我们没有忘记任何方法。 但是我们可以通过以下方面更一致和可靠地实现这一点（可在版本1 / TraceMyClasses.java中找到）：



	aspect TraceMyClasses {
	    pointcut myClass(): within(TwoDShape) || within(Circle) || within(Square);
	    pointcut myConstructor(): myClass() && execution(new(..));
	    pointcut myMethod(): myClass() && execution(* *(..));
	
	    before (): myConstructor() {
	        Trace.traceEntry("" + thisJoinPointStaticPart.getSignature());
	    }
	    after(): myConstructor() {
	        Trace.traceExit("" + thisJoinPointStaticPart.getSignature());
	    }
	
	    before (): myMethod() {
	        Trace.traceEntry("" + thisJoinPointStaticPart.getSignature());
	    }
	    after(): myMethod() {
	        Trace.traceExit("" + thisJoinPointStaticPart.getSignature());
	    }
	}


这方面在适当的时候执行跟踪调用。 根据这个方面，跟踪是在形状层次结构中定义的每个方法和构造函数的入口和出口处执行的。

在每个跟踪连接点之前和之后打印的是执行方法的签名。 由于签名是静态信息，我们可以通过thisJoinPointStaticPart获取它。

要运行此版本的跟踪，请转到目录InstallDir / examples并键入：


  	ajc -argfile tracing/tracev1.lst

运行tracing.version1.TraceMyClasses的主要方法应该产生输出：

	  --> tracing.TwoDShape(double, double)
	  <-- tracing.TwoDShape(double, double)
	  --> tracing.Circle(double, double, double)
	  <-- tracing.Circle(double, double, double)
	  --> tracing.TwoDShape(double, double)
	  <-- tracing.TwoDShape(double, double)
	  --> tracing.Circle(double, double, double)
	  <-- tracing.Circle(double, double, double)
	  --> tracing.Circle(double)
	  <-- tracing.Circle(double)
	  --> tracing.TwoDShape(double, double)
	  <-- tracing.TwoDShape(double, double)
	  --> tracing.Square(double, double, double)
	  <-- tracing.Square(double, double, double)
	  --> tracing.Square(double, double)
	  <-- tracing.Square(double, double)
	  --> double tracing.Circle.perimeter()
	  <-- double tracing.Circle.perimeter()
	c1.perimeter() = 12.566370614359172
	  --> double tracing.Circle.area()
	  <-- double tracing.Circle.area()
	c1.area() = 12.566370614359172
	  --> double tracing.Square.perimeter()
	  <-- double tracing.Square.perimeter()
	s1.perimeter() = 4.0
	  --> double tracing.Square.area()
	  <-- double tracing.Square.area()
	s1.area() = 1.0
	  --> double tracing.TwoDShape.distance(TwoDShape)
	    --> double tracing.TwoDShape.getX()
	    <-- double tracing.TwoDShape.getX()
	    --> double tracing.TwoDShape.getY()
	    <-- double tracing.TwoDShape.getY()
	  <-- double tracing.TwoDShape.distance(TwoDShape)
	c2.distance(c1) = 4.242640687119285
	  --> double tracing.TwoDShape.distance(TwoDShape)
	    --> double tracing.TwoDShape.getX()
	    <-- double tracing.TwoDShape.getX()
	    --> double tracing.TwoDShape.getY()
	    <-- double tracing.TwoDShape.getY()
	  <-- double tracing.TwoDShape.distance(TwoDShape)
	s1.distance(c1) = 2.23606797749979
	  --> String tracing.Square.toString()
	    --> String tracing.TwoDShape.toString()
	    <-- String tracing.TwoDShape.toString()
	  <-- String tracing.Square.toString()
	s1.toString(): Square side = 1.0 @ (1.0, 2.0)


当TraceMyClasses.java没有提供给ajc时，该方面对系统没有任何影响，并且跟踪被拔出。

**追踪 - 版本2**


完成同样事情的另一种方法是编写可重用的跟踪方面，不仅可以用于这些应用程序类，还可以用于任何类。 一种方法是将Trace-version1的跟踪功能与TraceMyClasses-version1的横切支持相结合。 我们最终得到一个跟踪方面（在版本2 / Trace.java中找到），并带有以下公共接口

	abstract aspect Trace {
	
	    public static int TRACELEVEL = 2;
	    public static void initStream(PrintStream s) {...}
	    protected static void traceEntry(String str) {...}
	    protected static void traceExit(String str) {...}
	    abstract pointcut myClass();
	}

为了使用它，我们需要在版本2 / TraceMyClasses.java中定义我们自己的了解我们的应用程序类的子类：

	public aspect TraceMyClasses extends Trace {
	    pointcut myClass(): within(TwoDShape) || within(Circle) || within(Square);
	
	    public static void main(String[] args) {
	        Trace.TRACELEVEL = 2;
	        Trace.initStream(System.err);
	        ExampleMain.main(args);
	    }
	}

请注意，我们只是简单地创建了切入点类，这是超级方面的抽象切入点，具体。 要运行此版本的跟踪，请转到目录示例并键入：

	ajc -argfile tracing/tracev2.lst

文件tracev2.lst列出了应用程序类以及此版本的文件Trace.java和TraceMyClasses.java。 运行tracing.version2.TraceMyClasses的主要方法应输出与版本1完全相同的跟踪信息。

新的Trace类的整个实现是：


	abstract aspect Trace {
	
	    // implementation part
	
	    public static int TRACELEVEL = 2;
	    protected static PrintStream stream = System.err;
	    protected static int callDepth = 0;
	
	    public static void initStream(PrintStream s) {
	        stream = s;
	    }
	    protected static void traceEntry(String str) {
	        if (TRACELEVEL == 0) return;
	        if (TRACELEVEL == 2) callDepth++;
	        printEntering(str);
	    }
	    protected static void traceExit(String str) {
	        if (TRACELEVEL == 0) return;
	        printExiting(str);
	        if (TRACELEVEL == 2) callDepth--;
	    }
	    private static void printEntering(String str) {
	        printIndent();
	        stream.println("--> " + str);
	    }
	    private static void printExiting(String str) {
	        printIndent();
	        stream.println("<-- " + str);
	    }
	    private static void printIndent() {
	        for (int i = 0; i < callDepth; i++)
	            stream.print("  ");
	    }
	
	    // protocol part
	
	    abstract pointcut myClass();
	
	    pointcut myConstructor(): myClass() && execution(new(..));
	    pointcut myMethod(): myClass() && execution(* *(..));
	
	    before(): myConstructor() {
	        traceEntry("" + thisJoinPointStaticPart.getSignature());
	    }
	    after(): myConstructor() {
	        traceExit("" + thisJoinPointStaticPart.getSignature());
	    }
	
	    before(): myMethod() {
	        traceEntry("" + thisJoinPointStaticPart.getSignature());
	    }
	    after(): myMethod() {
	        traceExit("" + thisJoinPointStaticPart.getSignature());
	    }
	}


这个版本在几个微妙的方面不同于版本1。首先要注意的是，这个Trace类将跟踪的功能部分与跟踪调用的横切合并在一起。也就是说，在版本1中，跟踪支持（类Trace）和它的横切使用（由类TraceMyClasses）之间存在明显的分离。在这个版本中，这两件事合并在一起。这就是为什么这个类的描述明确地说“跟踪消息在构造函数和方法之前和之后被打印”，这正是我们首先想要的。也就是说，在这个版本中，呼叫的放置是由方面类本身确定的，从而使放置呼叫的机会更少。

这样做的结果是，不需要提供traceEntry和traceExit作为此类的公共操作。你可以看到它们被分类为受保护的。他们应该是建议的内部实施细节。

这方面的关键部分是作为定义切入点构造函数和方法的基础的抽象切入点类。尽管类是抽象的，因此没有提到具体的类，我们可以对它提出建议，也可以基于它提供切入点。这个想法是“我们不确切知道切入点会是什么，但是当我们这样做时，这就是我们想要做的。”在某些方面，抽象切入点与抽象方法类似。抽象方法不提供实现，但你知道具体的子类会这样，所以你可以调用这些方法。






### 生产方面 ###

### 豆的一面 ###

（这个例子的代码在InstallDir / examples / bean中。）

本示例检查了使Point对象成为具有绑定属性的Java bean的一个方面。

Java bean是可重用的软件组件，可以在构建器工具中进行可视化操作。一个对象成为一个bean的要求很少。 Bean必须定义一个无参数的构造函数，并且必须是Serializable或Externalizable。要被视为bean属性的对象的任何属性应该通过存在适当的get和set方法来表示，这些get和set方法的名称是getproperty和set属性，其中property是bean类中字段的名称。一些bean属性称为绑定属性，只要它们的值发生更改就会触发事件，以便所有已注册的侦听器（例如其他bean）都将被通知这些更改。创建绑定属性包括保存已注册侦听器的列表，以及在更改属性值的方法（例如setproperty方法）中创建和分派事件对象。

点是一个简单的类，表示具有直角坐标的点。 Point并不知道是否是bean：有x和y的设置方法，但它们不会触发事件，并且该类不可序列化。 Bound是一个使Point成为一个可序列化的类的方面，并使得它的get和set方法支持绑定的属性协议。

Point类

Point类是一个非常简单的类，具有简单的getter和setter，以及简单的矢量偏移方法。


	class Point {
	
	  protected int x = 0;
	  protected int y = 0;
	
	  public int getX() {
	    return x;
	  }
	
	  public int getY() {
	    return y;
	  }
	
	  public void setRectangular(int newX, int newY) {
	    setX(newX);
	    setY(newY);
	  }
	
	  public void setX(int newX) {
	    x = newX;
	  }
	
	  public void setY(int newY) {
	    y = newY;
	  }
	
	  public void offset(int deltaX, int deltaY) {
	    setRectangular(x + deltaX, y + deltaY);
	  }
	
	  public String toString() {
	    return "(" + getX() + ", " + getY() + ")" ;
	  }
	}


BoundPoint方面

BoundPoint方面负责Point的“beanness”。 它所做的第一件事是私下声明每个Point都有一个支持引用PropertyChangeSupport实例的支持字段。

	private PropertyChangeSupport Point.support = new PropertyChangeSupport（this）;

属性更改支持对象必须使用对其提供支持的bean的引用来构造，所以通过传递它作为Point的一个实例进行初始化。 由于支持字段在该方面是私人声明的，因此只有方面中的代码可以引用它。
该方面还声明了Point的用于注册和管理属性更改事件的侦听器的方法，该事件将工作委托给属性更改支持对象：


	public void Point.addPropertyChangeListener(PropertyChangeListener listener){
	    support.addPropertyChangeListener(listener);
	  }
	  public void Point.addPropertyChangeListener(String propertyName,
	                                              PropertyChangeListener listener){
	
	    support.addPropertyChangeListener(propertyName, listener);
	  }
	  public void Point.removePropertyChangeListener(String propertyName,
	                                                 PropertyChangeListener listener) {
	    support.removePropertyChangeListener(propertyName, listener);
	  }
	  public void Point.removePropertyChangeListener(PropertyChangeListener listener) {
	    support.removePropertyChangeListener(listener);
	  }
	  public void Point.hasListeners(String propertyName) {
	    support.hasListeners(propertyName);
	  }


该方面还负责确保Point实现Serializable接口：

  	declare parents: Point implements Serializable;

在Java中实现这个接口不需要任何方法来实现。 Point对象的序列化由默认的序列化方法提供。
setters切入点选择对Point的set方法的调用：任何名称以“set”开头并带有一个参数的方法。 setters（）的around建议存储X和Y属性的值，调用原始set方法，然后根据调用的set方法触发相应的属性更改事件。


	aspect BoundPoint {
	  private PropertyChangeSupport Point.support = new PropertyChangeSupport(this);
	
	  public void Point.addPropertyChangeListener(PropertyChangeListener listener){
	    support.addPropertyChangeListener(listener);
	  }
	  public void Point.addPropertyChangeListener(String propertyName,
	                                              PropertyChangeListener listener){
	
	    support.addPropertyChangeListener(propertyName, listener);
	  }
	  public void Point.removePropertyChangeListener(String propertyName,
	                                                 PropertyChangeListener listener) {
	    support.removePropertyChangeListener(propertyName, listener);
	  }
	  public void Point.removePropertyChangeListener(PropertyChangeListener listener) {
	    support.removePropertyChangeListener(listener);
	  }
	  public void Point.hasListeners(String propertyName) {
	    support.hasListeners(propertyName);
	  }
	
	  declare parents: Point implements Serializable;
	
	  pointcut setter(Point p): call(void Point.set*(*)) && target(p);
	
	  void around(Point p): setter(p) {
	        String propertyName =
	      thisJoinPointStaticPart.getSignature().getName().substring("set".length());
	        int oldX = p.getX();
	        int oldY = p.getY();
	        proceed(p);
	        if (propertyName.equals("X")){
	      firePropertyChange(p, propertyName, oldX, p.getX());
	        } else {
	      firePropertyChange(p, propertyName, oldY, p.getY());
	        }
	  }
	
	  void firePropertyChange(Point p,
	                          String property,
	                          double oldval,
	                          double newval) {
	        p.support.firePropertyChange(property,
	                                 new Double(oldval),
	                                 new Double(newval));
	  }
	}


测试程序

测试程序将自己注册为它创建的Point对象的属性更改侦听器，然后对该对象执行简单操作：调用其设置方法和偏移方法。 然后它将该点序列化并将其写入文件，然后将其读回。 保存和恢复点的结果是创建了一个新点。


	class Demo implements PropertyChangeListener {
	
	    static final String fileName = "test.tmp";
	
	    public void propertyChange(PropertyChangeEvent e){
	      System.out.println("Property " + e.getPropertyName() + " changed from " +
	         e.getOldValue() + " to " + e.getNewValue() );
	    }
	
	    public static void main(String[] args){
	      Point p1 = new Point();
	      p1.addPropertyChangeListener(new Demo());
	      System.out.println("p1 =" + p1);
	      p1.setRectangular(5,2);
	      System.out.println("p1 =" + p1);
	      p1.setX( 6 );
	      p1.setY( 3 );
	      System.out.println("p1 =" + p1);
	      p1.offset(6,4);
	      System.out.println("p1 =" + p1);
	      save(p1, fileName);
	      Point p2 = (Point) restore(fileName);
	      System.out.println("Had: " + p1);
	      System.out.println("Got: " + p2);
	      }
	    ...
	  }

编译并运行示例

要编译并运行此示例，请转到示例目录并输入：


	ajc -argfile bean/files.lst
	java bean.Demo


主题/观察员协议

（这个例子的代码在InstallDir / examples / observer中。）

本演示说明Subject / Observer设计模式如何用方面进行编码。

该演示由以下内容组成：一个彩色标签是一种可呈现对象，它具有循环一组颜色的颜色，以及一个记录已经过的循环数的数字。一个按钮是一个操作项目，记录它被点击的时间。

通过这两种对象，我们可以建立一个主题/观察者关系，其中彩色标签观察按钮的点击;也就是说，彩色标签是观察者，按钮是主体。

演示使用Subject / Observer设计模式进行设计和实施。这个例子的其余部分解释了这个演示的类和方面，并告诉你如何运行它。

通用组件

该协议的通用部分是接口Subject和Observer，以及抽象方面SubjectObserverProtocol。 Subject接口很简单，包含添加，删除和查看Observer对象的方法以及获取有关状态更改的数据的方法：


    interface Subject {
      void addObserver(Observer obs);
      void removeObserver(Observer obs);
      Vector getObservers();
      Object getData();
  }

Observer接口非常简单，设置和获取Subject对象的方法以及在主题更新时调用的方法。


	 interface Observer {
	      void setSubject(Subject s);
	      Subject getSubject();
	      void update();
	  }

SubjectObserverProtocol方面在其中包含协议的所有通用部分，即当主体中的某些状态发生变化时如何触发Observer对象的更新方法。


	abstract aspect SubjectObserverProtocol {
	
	      abstract pointcut stateChanges(Subject s);
	
	      after(Subject s): stateChanges(s) {
	          for (int i = 0; i < s.getObservers().size(); i++) {
	              ((Observer)s.getObservers().elementAt(i)).update();
	          }
	      }
	
	      private Vector Subject.observers = new Vector();
	      public void   Subject.addObserver(Observer obs) {
	          observers.addElement(obs);
	          obs.setSubject(this);
	      }
	      public void   Subject.removeObserver(Observer obs) {
	          observers.removeElement(obs);
	          obs.setSubject(null);
	      }
	      public Vector Subject.getObservers() { return observers; }
	
	      private Subject Observer.subject = null;
	      public void     Observer.setSubject(Subject s) { subject = s; }
	      public Subject  Observer.getSubject() { return subject; }
	
	  }


请注意，这方面有三件事。 它定义了扩展方面可以覆盖的抽象切入点。 它定义了应该在切入点的连接点之后运行的建议。 并且它声明了一个inter-tpye字段和两个inter-type方法，以便每个Observer可以保存它的Subject。


应用程序类

Button对象扩展java.awt.Button，并且他们所做的全部工作都是确保在单击按钮时调用void click（）方法。


	 class Button extends java.awt.Button {
	
	      static final Color  defaultBackgroundColor = Color.gray;
	      static final Color  defaultForegroundColor = Color.black;
	      static final String defaultText = "cycle color";
	
	      Button(Display display) {
	          super();
	          setLabel(defaultText);
	          setBackground(defaultBackgroundColor);
	          setForeground(defaultForegroundColor);
	          addActionListener(new ActionListener() {
	                  public void actionPerformed(ActionEvent e) {
	                      Button.this.click();
	                  }
	              });
	          display.addToFrame(this);
	      }
	
	      public void click() {}
	
	  }


请注意，这个班级对作为主题一无所知。

ColorLabel对象是支持void colorCycle（）方法的标签。 再一次，他们对于成为观察员一无所知。


	class ColorLabel extends Label {
	
	      ColorLabel(Display display) {
	          super();
	          display.addToFrame(this);
	      }
	
	      final static Color[] colors = {Color.red, Color.blue,
	                                     Color.green, Color.magenta};
	      private int colorIndex = 0;
	      private int cycleCount = 0;
	      void colorCycle() {
	          cycleCount++;
	          colorIndex = (colorIndex + 1) % colors.length;
	          setBackground(colors[colorIndex]);
	          setText("" + cycleCount);
	      }
	  }


最后，SubjectObserverProtocolImpl实现主体/观察者协议，Button对象作为主体，ColorLabel对象作为观察者：


	package observer;
	
	import java.util.Vector;
	
	aspect SubjectObserverProtocolImpl extends SubjectObserverProtocol {
	
	    declare parents: Button implements Subject;
	    public Object Button.getData() { return this; }
	
	    declare parents: ColorLabel implements Observer;
	    public void    ColorLabel.update() {
	        colorCycle();
	    }
	
	    pointcut stateChanges(Subject s):
	        target(s) &&
	        call(void Button.click());
	
	}

它通过确保Button和ColorLabel实现适当的接口，声明它们实现这些接口所需的方法并为抽象stateChanges切入点提供定义来实现此目的。 现在，每次单击按钮时，观察该按钮的所有ColorLabel对象都将显示colorCycle。

编译和运行

Demo是开始演示的顶级课程。 它实例化一个两个按钮和三个观察者，并将它们作为主题和观察者链接在一起。 因此要运行演示，请转到示例目录并输入：


	 ajc -argfile observer/files.lst
	 java observer.Demo


### 简单的电信模拟 ###

（这个例子的代码在InstallDir / examples / telecom中。）

这个例子说明了一些依赖问题可以用方面编码的方法。它使用包括电话连接的简单模型的示例系统，其中使用方面添加了定时和计费功能，其中计费功能取决于计时功能。

应用程序

该示例应用程序是一个电话系统的简单模拟，客户在该系统中进行本地和长途电话的接入，合并和挂机。应用程序体系结构分为三层。

基本对象提供模拟客户，呼叫和连接的基本功能（常规呼叫有一个连接，电话会议有多个）。

定时功能关心的是连接的时间安排和保持每个客户的总连接时间。方面用于为每个连接添加一个计时器并管理每个客户的总时间。

计费功能与为客户收取他们所拨打的电话收费有关。方面用于计算每个连接的费用，并在连接终止时将费用添加到适当的客户帐单。计费方面建立在时间方面：它使用定时中定义的切入点，并使用与连接关联的计时器。

系统仿真有三种配置：基本，时间和计费。这三种配置的程序都在BasicSimulation，TimingSimulation和BillingSimulation类中。它们共享一个共同的超类AbstractSimulation，它定义了模拟本身运行的方法以及用于模拟流逝时间的等待方法。

基本对象

电信模拟包括Customer，Call和具有两个具体子类Local和LongDistance的抽象类Connection。客户有一个名字和一个数字区号。他们也有管理呼叫的方法。简单的调用是在一个客户（调用者）和另一个（接收者）之间进行的，Connection对象用于连接它们。超过两个客户之间的电话会议将涉及多个连接。一个客户可能一次参与多个呼叫。

![](http://www.eclipse.org/aspectj/doc/released/progguide/telecom.gif)


客户类

客户拥有呼叫，取货，挂机和合并的方法来管理呼叫。

	public class Customer {
	
	      private String name;
	      private int areacode;
	      private Vector calls = new Vector();
	
	      protected void removeCall(Call c){
	          calls.removeElement(c);
	      }
	
	      protected void addCall(Call c){
	          calls.addElement(c);
	      }
	
	      public Customer(String name, int areacode) {
	          this.name = name;
	          this.areacode = areacode;
	      }
	
	      public String toString() {
	          return name + "(" + areacode + ")";
	      }
	
	      public int getAreacode(){
	          return areacode;
	      }
	
	      public boolean localTo(Customer other){
	          return areacode == other.areacode;
	      }
	
	      public Call call(Customer receiver) {
	          Call call = new Call(this, receiver);
	          addCall(call);
	          return call;
	      }
	
	      public void pickup(Call call) {
	          call.pickup();
	          addCall(call);
	      }
	
	      public void hangup(Call call) {
	          call.hangup(this);
	          removeCall(call);
	      }
	
	      public void merge(Call call1, Call call2){
	          call1.merge(call2);
	          removeCall(call2);
	      }
	  }


Call类

呼叫是由作为客户的呼叫者和接收者创建的。 如果主叫方和接收方具有相同的区号，则可以使用本地连接建立呼叫（见下文），否则需要使用LongDistance连接。 一个呼叫包含了多个客户之间的连接。 最初呼叫者和接收者之间只有连接，但如果呼叫合并形成电话会议，则可以添加其他连接。

Connection类

Connection类模拟建立客户之间连接的物理细节。 它通过一个简单的状态机来完成（连接最初是PENDING，然后是COMPLETED，最后是DROPPED）。 消息被打印到控制台，以便可以观察到连接的状态。 连接是一个具有两个具体子类的抽象类：Local和LongDistance。


	abstract class Connection {
	
	      public static final int PENDING = 0;
	      public static final int COMPLETE = 1;
	      public static final int DROPPED = 2;
	
	      Customer caller, receiver;
	      private int state = PENDING;
	
	      Connection(Customer a, Customer b) {
	          this.caller = a;
	          this.receiver = b;
	      }
	
	      public int getState(){
	          return state;
	      }
	
	      public Customer getCaller() { return caller; }
	
	      public Customer getReceiver() { return receiver; }
	
	      void complete() {
	          state = COMPLETE;
	          System.out.println("connection completed");
	      }
	
	      void drop() {
	          state = DROPPED;
	          System.out.println("connection dropped");
	      }
	
	      public boolean connects(Customer c){
	          return (caller == c || receiver == c);
	      }
	
	  }

本地和长距离课程
我们模拟支持的两种连接是本地和长距离连接。
	
	 class Local extends Connection {
	      Local(Customer a, Customer b) {
	          super(a, b);
	          System.out.println("[new local connection from " +
	             a + " to " + b + "]");
	      }
	  }
	  class LongDistance extends Connection {
	      LongDistance(Customer a, Customer b) {
	          super(a, b);
	          System.out.println("[new long distance connection from " +
	              a + " to " + b + "]");
	      }
	  }


编译和运行基本仿真

基本系统的源文件在basic.lst文件中列出。 要构建并运行基本系统，请在shell窗口中输入以下命令：

	ajc -argfile telecom / basic.lst
	java telecom.BasicSimulation
时机方面

定时方面通过启动和停止与每个连接关联的定时器来跟踪每个客户的总连接时间。 它使用一些辅助类：

Timer类

Timer对象只是记录启动和停止的当前时间，并在询问经过时间时返回它们的差异。 方面TimerLog（下面）可用于使开始和停止时间打印到标准输出。


	class Timer {
	      long startTime, stopTime;
	
	      public void start() {
	          startTime = System.currentTimeMillis();
	          stopTime = startTime;
	      }
	
	      public void stop() {
	          stopTime = System.currentTimeMillis();
	      }
	
	      public long getTime() {
	          return stopTime - startTime;
	      }
	  }

TimerLog方面

TimerLog方面可以包含在构建中以使定时器在启动和停止时进行通告。


	public aspect TimerLog {
	
	    after(Timer t): target(t) && call(* Timer.start())  {
	      System.err.println("Timer started: " + t.startTime);
	    }
	
	    after(Timer t): target(t) && call(* Timer.stop()) {
	      System.err.println("Timer stopped: " + t.stopTime);
	    }
	}


时机方面

定时方面是为客户声明一个类型间字段totalConnectTime来存储每个客户的累计连接时间。 它还声明每个Connection对象都有一个计时器。

 	public long Customer.totalConnectTime = 0;
    private Timer Connection.timer = new Timer();
两条after通知确保定时器在连接完成时启动，并在断开时停止。 切入点endTiming被定义为可以由计费方面使用。
	
	
	public aspect Timing {
	
	    public long Customer.totalConnectTime = 0;
	
	    public long getTotalConnectTime(Customer cust) {
	        return cust.totalConnectTime;
	    }
	    private Timer Connection.timer = new Timer();
	    public Timer getTimer(Connection conn) { return conn.timer; }
	
	    after (Connection c): target(c) && call(void Connection.complete()) {
	        getTimer(c).start();
	    }
	
	    pointcut endTiming(Connection c): target(c) &&
	        call(void Connection.drop());
	
	    after(Connection c): endTiming(c) {
	        getTimer(c).stop();
	        c.getCaller().totalConnectTime += getTimer(c).getTime();
	        c.getReceiver().totalConnectTime += getTimer(c).getTime();
	    }
	}


计费方面

计费系统在计时的基础上向电信应用添加计费功能。

帐单方面声明每个连接都有一个付款人类型间字段，用于指示由谁发起呼叫，以及由谁负责付款。 它还声明了Connection的类型间方法callRate，以便本地和长途电话的收费可以不同。 通话费用必须在计时器停止后计算; 关于切入点的后续建议Timing.endTiming做到了这一点，并且Billing被声明为比Timing更先例，以确保此建议在Timing的建议之后在同一个连接点上运行。 最后，它为Customer声明inter-type方法和字段以处理totalCharge。


	public aspect Billing {
	    // precedence required to get advice on endtiming in the right order
	    declare precedence: Billing, Timing;
	
	    public static final long LOCAL_RATE = 3;
	    public static final long LONG_DISTANCE_RATE = 10;
	
	    public Customer Connection.payer;
	    public Customer getPayer(Connection conn) { return conn.payer; }
	
	    after(Customer cust) returning (Connection conn):
	        args(cust, ..) && call(Connection+.new(..)) {
	        conn.payer = cust;
	    }
	
	    public abstract long Connection.callRate();
	
	    public long LongDistance.callRate() { return LONG_DISTANCE_RATE; }
	    public long Local.callRate() { return LOCAL_RATE; }
	
	    after(Connection conn): Timing.endTiming(conn) {
	        long time = Timing.aspectOf().getTimer(conn).getTime();
	        long rate = conn.callRate();
	        long cost = rate * time;
	        getPayer(conn).addCharge(cost);
	    }
	
	    public long Customer.totalCharge = 0;
	    public long getTotalCharge(Customer cust) { return cust.totalCharge; }
	
	    public void Customer.addCharge(long charge){
	        totalCharge += charge;
	    }
	}


访问类型间的状态

定时和计费两个方面都包含系统其余部分可能要访问的操作的定义。 例如，当运行一个或两个方面的模拟时，我们想知道每个客户花费在电话上的时间以及他们的账单有多大。 这些信息也存储在类中，但是它们通过方面的静态方法来访问，因为它们引用的状态对方面是私有的。

看看文件TimingSimulation.java。 此类最重要的方法是方法报告（Customer），该方法报告用于超类AbstractSimulation的方法运行中。 此方法旨在打印客户的状态，与时序功能有关。


	 protected void report(Customer c){
	      Timing t = Timing.aspectOf();
	      System.out.println(c + " spent " + t.getTotalConnectTime(c));
	  }


编译和运行

文件timing.lst和billing.lst包含定时和计费配置的文件列表。 要仅使用计时功能构建和运行应用程序，请转到目录示例并输入：

   ajc -argfile telecom / timing.lst
   java telecom.TimingSimulation
要使用计时和计费功能构建和运行应用程序，请转至目录示例并输入：

   ajc -argfile telecom / billing.lst
   java telecom.BillingSimulation
讨论

计费和计时之间存在一些明确的相关性：

- 计费被声明比计时更先例，以便计费后的通知在计时之后运行，当它们在相同的连接点上时。

- 计费使用切入点Timing.endTiming。

- 结算需要访问与连接关联的计时器。


### 可重用方面 ###

使用Aspects追踪，重访

（这个例子的代码在InstallDir / examples / tracing中。）

追踪 - 版本3

不将方法traceEntry和traceExit公开为公共操作的一个优点是，我们可以轻松更改其接口，而不会在其他代码中产生任何显着后果。

再次考虑没有AspectJ的程序。 例如，假设在稍后的某个点跟踪更改的要求，指出跟踪消息应始终包含正在跟踪方法的对象的字符串表示形式。 这可以通过至少两种方式来实现。 一种方法是保持方法traceEntry和traceExit的接口像以前一样，
	
	 public static void traceEntry(String str);
	  public static void traceExit(String str);



在这种情况下，调用者负责确保对象的字符串表示形式是作为参数给定的字符串的一部分。所以，通话必须如下所示：

	Trace.traceEntry（“Square.distance in”+ toString（））;
另一种方法是在跟踪操作中使用第二个参数来强制执行要求，例如

	public static void traceEntry（String str，Object obj）;	
	public static void traceExit（String str，Object obj）;
在这种情况下，调用者仍然负责发送正确的对象，但至少有一些保证会传递一些对象。来电将如下所示：

	Trace.traceEntry（“Square.distance”，this）;
无论哪种情况，对跟踪要求的这种改变都会在其余的代码中产生巨大的影响 - 每次调用跟踪操作traceEntry和traceExit都必须改变！

这是跟踪方面的另一个优势。我们已经看到在版本2中traceEntry和traceExit没有公开。所以改变它们的接口或者它们的使用方式，在Trace类中只有很小的作用。以下是关于Trace 3版本实施的部分视图。在评论中强调了与版本2的不同之处：

	
	abstract aspect Trace {
	
	    public static int TRACELEVEL = 0;
	    protected static PrintStream stream = null;
	    protected static int callDepth = 0;
	
	    public static void initStream(PrintStream s) {
	        stream = s;
	    }
	
	    protected static void traceEntry(String str, Object o) {
	        if (TRACELEVEL == 0) return;
	        if (TRACELEVEL == 2) callDepth++;
	        printEntering(str + ": " + o.toString());
	    }
	
	    protected static void traceExit(String str, Object o) {
	        if (TRACELEVEL == 0) return;
	        printExiting(str + ": " + o.toString());
	        if (TRACELEVEL == 2) callDepth--;
	    }
	
	    private static void printEntering(String str) {
	        printIndent();
	        stream.println("Entering " + str);
	    }
	
	    private static void printExiting(String str) {
	        printIndent();
	        stream.println("Exiting " + str);
	    }
	
	    private static void printIndent() {
	        for (int i = 0; i < callDepth; i++)
	            stream.print("  ");
	    }
	
	    abstract pointcut myClass(Object obj);
	
	    pointcut myConstructor(Object obj): myClass(obj) && execution(new(..));
	    pointcut myMethod(Object obj): myClass(obj) &&
	        execution(* *(..)) && !execution(String toString());
	
	    before(Object obj): myConstructor(obj) {
	        traceEntry("" + thisJoinPointStaticPart.getSignature(), obj);
	    }
	    after(Object obj): myConstructor(obj) {
	        traceExit("" + thisJoinPointStaticPart.getSignature(), obj);
	    }
	
	    before(Object obj): myMethod(obj) {
	        traceEntry("" + thisJoinPointStaticPart.getSignature(), obj);
	    }
	    after(Object obj): myMethod(obj) {
	        traceExit("" + thisJoinPointStaticPart.getSignature(), obj);
	    }
	}


如您所见，我们决定通过保留方法traceEntry和traceExit的接口来应用第一个设计。但这并不重要 - 我们可以轻松应用第二种设计（目录examples / tracing / version3中的代码具有第二种设计）。重点在于跟踪需求中这种变化的影响仅限于跟踪方面类。

值得注意的一个实现变化是切入点的规范。他们现在揭露这个物体。为了与版本2的行为保持完全一致，我们应该包含静态方法的跟踪，为静态方法定义另一个切入点并提供建议。我们把它作为一个练习。

而且，我们必须从方法切入点中排除方法的执行连接点toString。这里的问题是toString被从通知内部调用。因此，如果我们追踪它，我们将以无限次的递归调用结束。这是一个微妙的观点，在撰写建议时你必须意识到这一点。如果建议回调对象，则总会有递归的可能性。记住这一点！

实际上，如果有调用其中的其他跟踪方法的话，仅仅排除执行连接点可能是不够的 - 在这种情况下，限制应该是


	&&！cflow（execution（String toString（）））
不包括执行toString方法和该执行下的所有连接点。

总之，为了实现跟踪需求的变化，我们必须对Trace方面类的实现进行一些更改，包括更改切入点的规范。 这很自然。 但是实施变化局限于这方面。 没有方面，我们将不得不改变每个应用程序类的实现。

最后，要运行此版本的跟踪，请转至目录示例并输入：

	ajc -argfile tracing / tracev3.lst
文件tracev3.lst列出了应用程序类以及此版本的文件Trace.java和TraceMyClasses.java。 要运行该程序，请键入

	java tracing.version3.TraceMyClasses
输出应该是：


	 --> tracing.TwoDShape(double, double)
	  <-- tracing.TwoDShape(double, double)
	  --> tracing.Circle(double, double, double)
	  <-- tracing.Circle(double, double, double)
	  --> tracing.TwoDShape(double, double)
	  <-- tracing.TwoDShape(double, double)
	  --> tracing.Circle(double, double, double)
	  <-- tracing.Circle(double, double, double)
	  --> tracing.Circle(double)
	  <-- tracing.Circle(double)
	  --> tracing.TwoDShape(double, double)
	  <-- tracing.TwoDShape(double, double)
	  --> tracing.Square(double, double, double)
	  <-- tracing.Square(double, double, double)
	  --> tracing.Square(double, double)
	  <-- tracing.Square(double, double)
	  --> double tracing.Circle.perimeter()
	  <-- double tracing.Circle.perimeter()
	c1.perimeter() = 12.566370614359172
	  --> double tracing.Circle.area()
	  <-- double tracing.Circle.area()
	c1.area() = 12.566370614359172
	  --> double tracing.Square.perimeter()
	  <-- double tracing.Square.perimeter()
	s1.perimeter() = 4.0
	  --> double tracing.Square.area()
	  <-- double tracing.Square.area()
	s1.area() = 1.0
	  --> double tracing.TwoDShape.distance(TwoDShape)
	    --> double tracing.TwoDShape.getX()
	    <-- double tracing.TwoDShape.getX()
	    --> double tracing.TwoDShape.getY()
	    <-- double tracing.TwoDShape.getY()
	  <-- double tracing.TwoDShape.distance(TwoDShape)
	c2.distance(c1) = 4.242640687119285
	  --> double tracing.TwoDShape.distance(TwoDShape)
	    --> double tracing.TwoDShape.getX()
	    <-- double tracing.TwoDShape.getX()
	    --> double tracing.TwoDShape.getY()
	    <-- double tracing.TwoDShape.getY()
	  <-- double tracing.TwoDShape.distance(TwoDShape)
	s1.distance(c1) = 2.23606797749979
	  --> String tracing.Square.toString()
	    --> String tracing.TwoDShape.toString()
	    <-- String tracing.TwoDShape.toString()
	  <-- String tracing.Square.toString()
	s1.toString(): Square side = 1.0 @ (1.0, 2.0)