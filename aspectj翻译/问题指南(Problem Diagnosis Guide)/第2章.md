## Debugging Pointcuts ##

### 简介 ###

本节介绍如何使用通常的迭代和分解方法编写和调试切入点。 当他们的建议不匹配时，新用户经常难住。 这意味着切入点不匹配; 他们重写切入点，但它仍然不匹配，没有新的信息。 如果每次迭代涉及构建，部署和测试复杂的应用程序，这可能会令人沮丧。 学会将其分解，尤其是编译时可以检查的部分，可以节省大量时间。

### 调试连接点 ###

自上而下，然后自下而上。自上而下，通过首先写评论来指定责任来起草重要方面。咨询责任通常采用“When X, do Y.”的形式。对于“When X”的切入点责任往往采取“When [join points] [in locations] [are ...]”的形式。这些[]常常被翻译成命名切入点（比如（Client）&& args（Context）`中的`libraryCalls（）&&），它们在评论中形成了明文意义的桥梁（例如`// when客户端仅将上下文传递到库中）。这使您可以独立调试切入点的各个部分。

自下而上（构建每个部分），考虑每个原始切入点指示符（PCD），然后是组合，然后是任何隐式约束：

1. 它应该匹配什么样的连接点?（`constructor-call`? `field-get`?)?这转换为使用已分类的切点（`call(..)`, `get(..)`等）。

2. 这些需要使用within限制词么？这转换为`within{code}(..)`。如果是，应该始终使用它来加速编织。

3. 什么运行时限制和上下文应该是真实的并且在每个连接点都可用？这转换为`this()`, `target()`, `args()`, `cflow{below}()` 和 `if(..)`.。

4. 问题是否有任何通知或实施限制？这包括了解实现说明中AspectJ编程指南部分列出的对Java字节码强加的AspectJ的几个约束。

在编译时使用声明警告来迭代切入点会更快（更好的是，在AJDT的最新版本中，在分析时识别出一些错误）。从切点可以静态确定的部分开始（即，它们不涉及上面列出的运行时PCD）。如果由于所有的AspectJ编织而编译本身需要很长时间，那么尝试仅包含使用原型切入点的调试方面，并within(..)使用范围限制。

原始切入点中的一些错误：

- `this(Foo) && execution(static * *(..))`：在静态上下文中没有`this`，所以不应该在静态上下文中使用`this()` or `target()`。当分别定位静态上下文时。这种情况通常发生在你想要说“所有bar中对Foo的调用”等事情时发生，并且你只能选出对Foo的实例方法的调用，或者试图从Bar的静态方法中挑选出调用。

- `target(Foo) && call(new(..)`：这永远不会匹配。在constructor-call连接点中，没有目标，因为对象尚未创建。

- `call(* Foo.*(..))`：`Foo`指的是调用引用的编译时类型，而不是实现类。在1.4之前的Java中，编译时类型被呈现为定义类型，而不是引用类型;这在1.4中得到了纠正（如使用带有-1.4标志的ajc所示）大多数人应该使用`target（Foo）&& call（...）`。

- `execution(* Foo.bar(..))`：Foo的execution连接点总是在Foo内，所以这不会挑出任何重载bar（..）。例如使用`target（Foo）&& execution（* bar（..））`方法。

- `within(Foo)`：匿名类型在编织时并不知道在词法封闭类型中（Java字节码的限制）。

组合中的一些错误：

- `call(* foo(Bar, Foo)) && args(Foo)`：这永远不会匹配。`args(..)`中的参数是依赖于位置的，所以`args(Foo)`只挑选出只有一个可能参数的连接点，类型为Foo。根据需要使用不确定参数运算符'..'，例如`args(Foo, ..)`。

- `call(* foo()) && execution(* foo())`：这永远不会匹配。每个切入点在匹配的每个连接点都必须为真。对于不同类型的连接点的联合（这里call或execution），使用'||'。例如，要匹配方法调用和字段获取连接点，请使用`call(* ...) || get(...)`。


隐含通知约束中的一些错误：

`after () returning (Foo foo) : ...`：建议可以绑定返回的对象或抛出的异常。当通知根据绑定对象的运行时类型运行时，它的作用就像`target()`, `this()`,或`args()`一样有效，尽管它并不是切入点的一部分。

实现要求中的一些错误：

`ajc`必须控制连接点的代码才能实现连接点。这意味着所有连接点都有一个隐含的`within({code under the control of the compiler})`，对于某些连接点还有一些额外的警告。例如：以异常处理程序为例：无法确定原始处理程序结束时的字节码，因此`ajc`无法在处理程序连接点的建议之后实现。 （因为这些都是基于每个连接点的，所以应该考虑每个相应的原始切入点指示符。）与上述原始PCD的错误不同，编译器会针对这些注意事项发出错误。

`call(@SuperAnnotation Subclass.meth()`：注释并不是默认继承的，例如，如果切入点指定了注释，那么该方法的子类实现将不匹配。